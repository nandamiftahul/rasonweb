<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Radiosonde Viewer</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body, html { margin:0; padding:0; height:100%; font-family:sans-serif; }
    #map { height:100%; width:100%; }

    #controls {
      position:absolute;
      bottom:10px;
      left:50%;
      transform:translateX(-50%);
      background:white;
      padding:8px;
      border-radius:8px;
      box-shadow:0 0 6px rgba(0,0,0,0.4);
      display:flex;
      align-items:center;
      gap:6px;
      z-index:1000;
    }

    #infoPanel, #metaPanel {
      position:absolute;
      top:80px;
      background:white;
      padding:10px;
      border-radius:6px;
      box-shadow:0 0 6px rgba(0,0,0,0.4);
      z-index:1000;
      font-size:14px;
      width:260px;
      max-height:80%;
      overflow-y:auto;
    }
    #infoPanel { right:20px; }
    #metaPanel { left:20px; }

    #infoPanel, #metaPanel {
      backdrop-filter: blur(10px);
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid rgba(0, 0, 0, 0.1);
      color: #111;
      font-family: "Inter", sans-serif;
      transition: all 0.3s ease;
    }
    
    #infoPanel h4, #metaPanel h4 {
      margin: 6px 0;
      color: #0a2a6b;
      font-size: 15px;
      border-bottom: 1px solid #ccc;
      padding-bottom: 2px;
    }
    
    #infoPanel b, #metaPanel b {
      color: #004aad;
    }


    #chartsPanel {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);  /
      width: 1110px;
      height: 320px;
      background: white;
      border-radius: 6px;
      box-shadow: 0 0 6px rgba(0,0,0,0.4);
      z-index: 1000;
      padding: 6px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .chartBox { flex:1; height:100%; }

    #topBar {
      position:absolute;
      top:10px;
      right:10px;
      z-index:1200;
      background:white;
      padding:6px 10px;
      border-radius:6px;
      box-shadow:0 0 6px rgba(0,0,0,0.3);
    }
    #topBar a { text-decoration:none; color:#333; font-size:14px; }
    
    .panel-btn {
      border: none;
      background: none;
      font-size: 16px;
      cursor: pointer;
      color: #004aad;
      transition: 0.2s;
    }
    .panel-btn:hover {
      transform: scale(1.3);
    }

  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Upload form -->
  <form method="POST" enctype="multipart/form-data"
        style="position:absolute; top:10px; left:10px; z-index:1000; background:white; padding:6px; border-radius:6px;">
    <input type="file" name="rasonfiles" accept=".bufr,.bfr,.bfh,.bin">
    <button type="submit">Upload Radiosonde</button>
  </form>

  <!-- Logout button -->
  <div id="topBar">
    Hi, {{ user }} |
    <a href="{{ url_for('dashboard') }}">üè† Dashboard</a> |
    <a href="{{ url_for('logout') }}">üö™ Logout</a>
  </div>

  <!-- Metadata panel -->
  <div id="metaPanel">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <b>Station Metadata</b>
      <button id="toggleMeta" class="panel-btn">‚àí</button>
    </div>
    <div id="metaContent">No metadata</div>
  </div>

  <!-- Per-level info panel -->
  <div id="infoPanel">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <b>Level Info</b>
      <button id="toggleInfo" class="panel-btn">‚àí</button>
    </div>
    <div id="infoContent">No data loaded</div>
  </div>

  <!-- Charts Panel -->
  <div id="chartsPanel">
    <div class="chartBox"><canvas id="dirChart"></canvas></div>
    <div class="chartBox"><canvas id="windChart"></canvas></div>
    <div class="chartBox"><canvas id="thermoChart"></canvas></div>
  </div>

  <!-- Controls -->
  <div id="controls">
    <button type="button" onclick="prevFrame()">‚èÆ Prev</button>
    <button type="button" onclick="togglePlay()"><span id="playBtn">‚ñ∂ Play</span></button>
    <button type="button" onclick="nextFrame()">Next ‚è≠</button>
    <input type="range" id="frameSlider" min="0" value="0" step="1" style="width:200px;">
    <span id="frameText">0/0</span>
    <button type="button" onclick="toggleCharts()" id="chartsBtn">üìä Hide Charts</button>
  </div>

  <script>
    // --- Map ---
    const map = L.map('map', { zoomControl: false }).setView([0,0], 3);
    L.control.zoom({ position: 'bottomright' }).addTo(map);
    
    // --- Base maps ---
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '¬© OpenStreetMap'
    });
    
    const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 19, attribution: 'Tiles ¬© Esri ‚Äî Source: Esri, i-cubed, USDA, USGS'
    });
    
    const esriTerrain = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 13, attribution: 'Tiles ¬© Esri ‚Äî Source: Esri, USGS, NOAA'
    });
    
    const googleHybrid = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
      maxZoom: 20, attribution: '¬© Google Maps Hybrid'
    });
    
    // --- Default layer ---
    osm.addTo(map);
    
    // --- Layer control menu ---
    const baseMaps = {
      "üó∫Ô∏è OpenStreetMap": osm,
      "üõ∞Ô∏è Satellite (Esri)": esriSat,
      "üåç Terrain (Esri)": esriTerrain,
      "üß≠ Hybrid (Google)": googleHybrid
    };
    L.control.layers(baseMaps, {}, { position: 'bottomleft', collapsed: true }).addTo(map);
    

    // --- State ---
    let frame = 0, total = 0, playing = false, timer = null;
    let balloonMarker = null, pathLine = null;
    let allLevels = [];  // full profile in memory
    let launchDateUTC = null; // Date object (UTC) parsed from metadata.launch_time

    // --- Balloon icon ---
    const balloonIcon = L.divIcon({
      html: "<div style='font-size:64px;'>üéà</div>",
      className: "",
      iconSize: [64, 64],
      iconAnchor: [32, 64]
    });

    // --- Charts ---
    const windChartData = { datasets: [
      { label: 'Ascent Rate (m/s)', data: [], borderColor: 'blue', showLine:true },
      { label: 'Wind Speed (m/s)', data: [], borderColor: 'red', showLine:true }
    ]};
    const windChart = new Chart(document.getElementById('windChart'), {
      type: 'scatter', data: windChartData,
      options: {
        responsive: true, maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'bottom',
            align: 'center',
            labels: {
              boxWidth: 12,
              padding: 16,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          }
        },
        scales: {
          x: { title: { display: true, text: 'Value (m/s)' } },
          y: { title: { display: true, text: 'Height (m)' }, suggestedMin: 0, suggestedMax: 25000 }
        }
      }
    });

    // --- Wind Direction Chart ---
    const dirChartData = { datasets: [
      { label: 'Wind Dir (¬∞)', data: [], borderColor: 'green', showLine:true }
    ]};
    const dirChart = new Chart(document.getElementById('dirChart'), {
      type: 'scatter', data: dirChartData,
      options: {
        responsive: true, maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'bottom',
            align: 'center',
            labels: {
              boxWidth: 12,
              padding: 16,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          }
        },
        scales: {
          x: { title: { display: true, text: 'Direction (¬∞)' }, min:0, max:360 },
          y: { title: { display: true, text: 'Height (m)' }, suggestedMin: 0, suggestedMax: 25000 }
        }
      }
    });
    

    const thermoChartData = { datasets: [
      { label: 'Temp (¬∞C)', data: [], borderColor: 'orange', showLine:true },
      { label: 'Dewpoint (¬∞C)', data: [], borderColor: 'cyan', showLine:true }
    ]};
    const thermoChart = new Chart(document.getElementById('thermoChart'), {
      type: 'scatter', data: thermoChartData,
      options: {
        responsive: true, maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'bottom',
            align: 'center',
            labels: {
              boxWidth: 12,
              padding: 16,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          }
        },
        scales: {
          x: { title: { display: true, text: 'Temperature (¬∞C)' } },
          y: { title: { display: true, text: 'Height (m)' }, suggestedMin: 0, suggestedMax: 25000 }
        }
      }
    });

    // --- Toggle Charts Panel ---
    function toggleCharts() {
      const panel = document.getElementById("chartsPanel");
      const btn = document.getElementById("chartsBtn");
      if (panel.style.display === "none") {
        panel.style.display = "flex";
        btn.innerText = "üìä Hide Charts";
      } else {
        panel.style.display = "none";
        btn.innerText = "üìä Show Charts";
      }
    }

    // --- Helpers for UTC time ---
    function parseLaunchUTC(str) {
      // expects "YYYY-MM-DD HH:MM:SS UTC"
      if (!str) return null;
      const iso = str.replace(' UTC', 'Z'); // force UTC
      const d = new Date(iso);
      return isNaN(d.getTime()) ? null : d;
    }
    function formatUTC(date) {
      // YYYY-MM-DD HH:MM:SS UTC
      const pad = n => String(n).padStart(2,'0');
      const y = date.getUTCFullYear();
      const m = pad(date.getUTCMonth()+1);
      const d = pad(date.getUTCDate());
      const hh = pad(date.getUTCHours());
      const mm = pad(date.getUTCMinutes());
      const ss = pad(date.getUTCSeconds());
      return `${y}-${m}-${d} ${hh}:${mm}:${ss} UTC`;
    }

    // Pretty labels for selected metadata keys
    const METADATA_LABELS = {
      launch_time: "Launch Time",
      station_lat: "Station Lat",
      station_lon: "Station Lon",
      station_height_m: "Station Height",
      radiosonde_serial_number: "Serial Number",
      radiosonde_operating_frequency: "Frequency",
      reason_for_termination: "Reason for Termination",
      type_of_pressure_sensor: "Pressure Sensor",
      type_of_temperature_sensor: "Temperature Sensor",
      type_of_humidity_sensor: "Humidity Sensor",
      type_of_balloon: "Balloon Type",
      type_of_gas_used_in_balloon: "Balloon Gas",
      software_version: "Software"
    };
  
    // Preferred display order
    const META_PRIMARY_ORDER = [
      "launch_time",
      "station_lat",
      "station_lon",
      "station_height_m",
      "radiosonde_serial_number",
      "radiosonde_operating_frequency",
      "reason_for_termination",
      "type_of_pressure_sensor",
      "type_of_temperature_sensor",
      "type_of_humidity_sensor",
      "type_of_balloon",
      "type_of_gas_used_in_balloon",
      "software_version"
    ];

    // Fallback maps to render "code ‚Äì meaning" if backend only sends numbers.
    const SENSOR_MAPS = {
      pressure_sensor_type: {0:"Unknown",1:"Aneroid",2:"Capacitive",3:"Other"},
      type_of_pressure_sensor: {0:"Unknown",1:"Aneroid",2:"Capacitive",3:"Other"},
    
      temperature_sensor_type: {0:"Unknown",1:"Thermistor",2:"Platinum",3:"Other"},
      type_of_temperature_sensor: {0:"Unknown",1:"Thermistor",2:"Platinum",3:"Other"},
    
      humidity_sensor_type: {0:"Unknown",1:"Hair",2:"Capacitive",3:"Carbon",4:"Other"},
      type_of_humidity_sensor: {0:"Unknown",1:"Hair",2:"Capacitive",3:"Carbon",4:"Other"},
    
      balloon_type: {0:"Unknown",1:"Latex",2:"Polyethylene",3:"Other"},
      type_of_balloon: {0:"Unknown",1:"Latex",2:"Polyethylene",3:"Other"},
    
      balloon_gas_type: {0:"Unknown",1:"Hydrogen",2:"Helium"},
      type_of_gas_used_in_balloon: {0:"Unknown",1:"Hydrogen",2:"Helium"},
    
      balloon_manufacturer: {0:"Unknown",1:"Totex",2:"Kaysam",3:"Other"},
    
      reason_for_termination: {
        0:"Not specified",1:"Balloon burst",2:"Battery exhausted",
        3:"Receiver failure",4:"Telemetry interrupted",5:"Manual termination",6:"Other"
      }
    };
    
    // Turn "1" ‚Üí "1 ‚Äì Aneroid" for known keys;
    // leave values that are already "1 ‚Äì Aneroid" unchanged.
    function formatMetaValue(key, value) {
      if (value == null || value === "") return "-";
    
      // If already formatted like "2 ‚Äì Hydrogen"
      if (typeof value === "string" && value.includes("‚Äì")) return value;
    
      // Try map with exact key
      let map = SENSOR_MAPS[key];
      if (!map) {
        // Try fallback: remove "type_of_" prefix
        const altKey = key.replace(/^type_of_/, "");
        map = SENSOR_MAPS[altKey];
      }
    
      const code = Number(value);
      if (map && Number.isFinite(code)) {
        const meaning = map[code] ?? "Unknown";
        return `${code} ‚Äì ${meaning}`;
      }
    
      return value;
    }
    
    // Map primary keys to possible alias keys the backend might send
    const ALT_KEYS = {
      type_of_pressure_sensor: "pressure_sensor_type",
      type_of_temperature_sensor: "temperature_sensor_type",
      type_of_humidity_sensor: "humidity_sensor_type",
      type_of_balloon: "balloon_type",
      type_of_gas_used_in_balloon: "balloon_gas_type",
      balloon_manufacturer: "balloon_manufacturer" // (no alias, keep for consistency)
    };
    
    // Safely retrieve the raw value for a metadata field (try primary, then alias)
    function getMeta(meta, key) {
      const v = meta[key];
      if (v !== undefined && v !== null && v !== "") return v;
      const alt = ALT_KEYS[key];
      if (alt && meta[alt] !== undefined && meta[alt] !== null && meta[alt] !== "") return meta[alt];
      return "-";
    }
    
    // --- Load metadata ---
    fetch('/metadata')
      .then(r => r.ok ? r.json() : {})
      .then(meta => {
        if (!meta || meta.error) return;
    
        launchDateUTC = parseLaunchUTC(meta.launch_time);
    
        let html = "";
    
        // --- Station info ---
        html += `<h4>üìç Station</h4>`;
        html += `<b>Launch Time</b>: ${formatMetaValue("launch_time", meta.launch_time)}<br>`;
        html += `<b>Lat</b>: ${meta.station_lat ?? "-"}<br>`;
        html += `<b>Lon</b>: ${meta.station_lon ?? "-"}<br>`;
        html += `<b>Height</b>: ${meta.station_height_m ?? "-"} m<br>`;
    
        // --- Radiosonde ---
        html += `<h4>üéà Radiosonde</h4>`;
        html += `<b>Serial</b>: ${meta.radiosonde_serial_number ?? "-"}<br>`;
        html += `<b>Frequency</b>: ${meta.radiosonde_operating_frequency ?? "-"}<br>`;
        html += `<b>Pressure Sensor</b>: ${formatMetaValue("type_of_pressure_sensor", getMeta(meta, "type_of_pressure_sensor"))}<br>`;
        html += `<b>Temp Sensor</b>: ${formatMetaValue("type_of_temperature_sensor", getMeta(meta, "type_of_temperature_sensor"))}<br>`;
        html += `<b>Humidity Sensor</b>: ${formatMetaValue("type_of_humidity_sensor", getMeta(meta, "type_of_humidity_sensor"))}<br>`;
        html += `<b>Software</b>: ${meta.software_version ?? "-"}<br>`;
    
        // --- Balloon ---
        html += `<h4>üéà Balloon</h4>`;
        html += `<b>Type</b>: ${formatMetaValue("type_of_balloon", getMeta(meta, "type_of_balloon"))}<br>`;
        html += `<b>Gas</b>: ${formatMetaValue("type_of_gas_used_in_balloon", getMeta(meta, "type_of_gas_used_in_balloon"))}<br>`;
        if (meta.balloon_manufacturer || getMeta(meta, "balloon_manufacturer") !== "-") {
          html += `<b>Manufacturer</b>: ${formatMetaValue("balloon_manufacturer", getMeta(meta, "balloon_manufacturer"))}<br>`;
        }

    
        // --- Flight results ---
        html += `<h4>‚úà Flight</h4>`;
        if (Array.isArray(meta.flight_issues) && meta.flight_issues.length > 0) {
          html += `<b>Status</b>: ${meta.flight_issues.join(", ")}<br>`;
        }
        html += `<b>Termination</b>: ${formatMetaValue("reason_for_termination", meta.reason_for_termination)}<br>`;
        html += `<b>End Pressure</b>: ${meta.end_pressure ?? "-"}<br>`;
        html += `<b>Max Height</b>: ${meta.max_height ?? "-"}<br>`;
        html += `<b>End Distance</b>: ${meta.end_distance ?? "-"}<br>`;
        html += `<b>Ascent Rate</b>: ${meta.avg_ascent_rate ?? "-"}<br>`;
    
        document.getElementById("metaContent").innerHTML = html;
      })
      .catch(() => {});

 
    // --- Load all levels ---
    initLevels();

    async function initLevels() {
      try {
        const r = await fetch('/all_levels');
        if (r.ok) {
          const arr = await r.json();
          if (Array.isArray(arr) && arr.length > 0) {
            allLevels = arr;
            total = allLevels.length;
            document.getElementById("frameSlider").max = Math.max(0, total - 1);
            updateFrameText(); // initial text with time if possible
            loadRason();
            return;
          }
        }
      } catch {}
      // Fallback using server-side total + /value?frame=
      const srvTotal = {{ total|default(0) }};
      if (srvTotal > 0) {
        const promises = [];
        for (let i = 0; i < srvTotal; i++) {
          promises.push(fetch(`/value?frame=${i}`).then(x => x.json()).catch(() => null));
        }
        const results = (await Promise.all(promises)).filter(x => x && !x.error);
        if (results.length) {
          allLevels = results;
          total = allLevels.length;
          document.getElementById("frameSlider").max = Math.max(0, total - 1);
          updateFrameText();
          loadRason();
        }
      }
    }

    function isFiniteNumber(x) {
      return typeof x === 'number' && Number.isFinite(x);
    }

    function updateFrameText() {
      let base = `${frame + 1}/${total}`;
      const data = allLevels[frame];
      if (data && data.time_s != null && launchDateUTC) {
        const t = Number(data.time_s) || 0;
        const ts = new Date(launchDateUTC.getTime() + t * 1000);
        base += ` | ${formatUTC(ts)} (t=${Math.round(t)} s)`;
      }
      document.getElementById("frameText").innerText = base;
    }

    function loadRason() {
      if (!allLevels.length) {
        document.getElementById("infoContent").innerText = "No radiosonde";
        return;
      }

      frame = (frame % allLevels.length + allLevels.length) % allLevels.length;
      const data = allLevels[frame];

      // UI
      document.getElementById("frameSlider").value = frame;
      updateFrameText();

      // Info (numbers 1 decimal; full precision for lat/lon)
      let html = "";
      for (const [k,v] of Object.entries(data)) {
        if (v == null) continue;
        if (k === "latitude" || k === "longitude") {
          html += `<b>${k}</b>: ${v}¬∞<br>`;
        } else if (typeof v === "number") {
          html += `<b>${k}</b>: ${Number(v).toFixed(1)}<br>`;
        } else {
          html += `<b>${k}</b>: ${v}<br>`;
        }
      }
      document.getElementById("infoContent").innerHTML = html || "No data";

      // Charts (rebuild subset 0..frame)
      const subset = allLevels.slice(0, frame + 1);
      windChartData.datasets[0].data = subset.map(l => ({ x: l.ascent_rate_mps ?? null, y: l.height_m }));
      windChartData.datasets[1].data = subset.map(l => ({ x: l.wind_speed_mps ?? null, y: l.height_m }));
      thermoChartData.datasets[0].data = subset.map(l => ({ x: l.temp_C ?? null, y: l.height_m }));
      thermoChartData.datasets[1].data = subset.map(l => ({ x: l.dewpoint_C ?? null, y: l.height_m }));
      dirChartData.datasets[0].data = subset.map(l => ({ x: l.wind_dir_deg ?? null, y: l.height_m }));
      
      // Auto-scale >25 km
      const h = data.height_m;
      if (isFiniteNumber(h) && h > 25000) {
        windChart.options.scales.y.suggestedMax = null;
        thermoChart.options.scales.y.suggestedMax = null;
        dirChart.options.scales.y.suggestedMax = null;
      } else {
        windChart.options.scales.y.suggestedMax = 25000;
        thermoChart.options.scales.y.suggestedMax = 25000;
        dirChart.options.scales.y.suggestedMax = 25000;
      }
      
      windChart.update();
      thermoChart.update();
      dirChart.update();
      

      // Balloon path up to current frame
      const trackCoords = subset
        .filter(l => isFiniteNumber(l.latitude) && isFiniteNumber(l.longitude))
        .map(l => [l.latitude, l.longitude]);

      if (isFiniteNumber(data.latitude) && isFiniteNumber(data.longitude)) {
        const latlng = [data.latitude, data.longitude];
        if (balloonMarker) balloonMarker.setLatLng(latlng);
        else balloonMarker = L.marker(latlng, { icon: balloonIcon }).addTo(map);
      
        // ‚úÖ Zoom otomatis ke posisi balon saat load pertama
        if (frame === 0) {
          if (trackCoords.length > 1) {
            setTimeout(() => map.fitBounds(trackCoords), 0);
          } else {
            map.setView(latlng, 9); // zoom manual kalau hanya 1 titik
          }
        }
      }


      if (trackCoords.length >= 2) {
        if (pathLine) pathLine.setLatLngs(trackCoords);
        else pathLine = L.polyline(trackCoords, { color: "red" }).addTo(map);
      } else if (pathLine) {
        pathLine.setLatLngs(trackCoords);
      }
    }

    function nextFrame() { if (!allLevels.length) return; frame = (frame + 1) % total; loadRason(); }
    function prevFrame() { if (!allLevels.length) return; frame = (frame - 1 + total) % total; loadRason(); }
    function togglePlay() {
      if (!allLevels.length) return;
      if (playing) { clearInterval(timer); playing=false; document.getElementById("playBtn").innerText="‚ñ∂ Play"; }
      else { timer=setInterval(nextFrame, 1000); playing=true; document.getElementById("playBtn").innerText="‚è∏ Pause"; }
    }
    document.getElementById("frameSlider").addEventListener("input", function () {
      if (!allLevels.length) return;
      frame = parseInt(this.value, 10) || 0;
      loadRason();
    });
    
    // --- Metadata toggle ---
    document.addEventListener("DOMContentLoaded", () => {
      const metaBtn = document.getElementById("toggleMeta");
      const metaContent = document.getElementById("metaContent");
      metaBtn.addEventListener("click", () => {
        const hidden = metaContent.style.display === "none";
        metaContent.style.display = hidden ? "block" : "none";
        metaBtn.textContent = hidden ? "‚àí" : "+";
      });
    
      const infoBtn = document.getElementById("toggleInfo");
      const infoContent = document.getElementById("infoContent");
      infoBtn.addEventListener("click", () => {
        const hidden = infoContent.style.display === "none";
        infoContent.style.display = hidden ? "block" : "none";
        infoBtn.textContent = hidden ? "‚àí" : "+";
      });
    });
    

  </script>
</body>
</html>
